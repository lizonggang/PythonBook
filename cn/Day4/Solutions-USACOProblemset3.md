### “另一头牛数字游戏”的解决方案

**我们的策略是模拟游戏，跟踪我们前进的步骤数量。 与往常一样，我们首先阅读输入。 我们还应该为答案保留一个计数器，它将计算步数**

```
read N
steps = 0
```

**现在问题告诉我们当N = 1时游戏结束。 这意味着我们必须继续，而N不是1，我们可以使用while循环。**
```
while N != 1:
```


**接下来，我们需要实际模拟游戏。 根据规则，如果N是偶数，我们将N除以2.我们知道，当我们将它除以2时，N是没有余数的，所以：**

```
if N%2 = 0:
    N /= 2
```

**否则（否则），N是奇数。 在这种情况下，问题是将N乘以3并加1：**
```
else :
    N = 3*N+1
```
**最后，我们需要更新我们的步骤变量，因为每次我们移动它都算作一个步骤。**
```
steps = steps + 1
```

**我们现在准备输出我们的答案！ 这是完整的代码：**

```
read N
steps = 0
while N != 1:
    if N%2 = 0:
        N /= 2
    else :
        N = 3*N+1
    steps = steps + 1
output steps
```


---

<br>

### “牛奶桶”解决方案

**对于这个问题，我们给出了三个尺寸为X，Y和M的桶。这个问题的目标是一次性将X或Y单位的牛奶准确地添加到尺寸为M的桶中以填充桶 越多越好。 在样品的情况下，大桶（尺寸M）的容量为77，两个较小的桶的尺寸为17和25.为了尽可能地填充大桶，FJ使用尺寸为17的桶三次并且 一次大小25桶，这个过程后大桶中的牛奶总量是17 * 3 + 25 * 1 = 76个单位。**

**读入输入（桶的容量）。 对于一般解决方案，该方法是找到a * x + b * y的最大值，使得a * x + b * y <= m。 这可以通过嵌套循环来检查，检查满足上述约束的a和y的所有组合。**

```
read x, y, m

answer = 0
a = 0
while a * x <= m:
    b = 0
    while b * y <= m:
        answer = max(answer, a * x + b * y)
        b += 1
    a += 1
print(answer)
```

**对于其他挑战，可以在不使用嵌套循环的情况下完成此操作。 而不是找到可以达到的最大牛奶量。 找出模数的最小值并从m的容量中减去。**

```
read x, y, m

answer = m
a = 0
while a * x <= m:
    answer = min(answer, (m - a * x) % y)
    a += 1
print(m - answer)
```

**使用此解决方案，例如，当a = 3时，（m - a * x）％y =（77 - 3 * 17）% 25 = 26%25 = 1.可获得的最小模数为1， 因此，桶的最大填充量是由模数减去的总容量：77-1 = 76，这与另一个解决方案得到的答案一致。**

