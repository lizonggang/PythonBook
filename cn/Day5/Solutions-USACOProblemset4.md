### “传送”的解决方案

**在这个问题中，有三种情况。首先，Farmer John可以在不使用单个传送的情况下从a点到b点。其次，Farmer John可以通过在x到y方向上使用传送来从a点到b点。最后，FJ可以在y到x方向上使用传送。这个问题的解决方案包括测试所有三个案例并找到最短的案例。**

**示例问题使用以下值：**
```
3 10 8 2
```

**这意味着FJ试图通过使用连接点2到点8的传送来从第3点到第10点。基本上，他有三个选项：从第3点到第2点，从传送到第8点，然后转到第10点;从第3点到第8点，传送到第2点，然后到第10点;或直接从第3点到第10点。这三个选项需要行程距离3,13和7.显然，3是最短的，因此它是正确的答案。一般来说，FJ必须测试所有三个案例并采用最短的案例。**

```
read a,b,x,y
distance = absoluteValue(a - b)
distance = min(distance, absoluteValue(a-x) + absoluteValue(b-y))
distance = min(distance, absoluteValue(a-y) + absoluteValue(b-x))
print distance
```

---

<br>

### “计数珠”的解决方案



**在我提出解决方案之前，让我们来看看如何解决样本案例：**

```
6
10 0 111
```

**在这种情况下，当我们遍历6个珠子时，我们计算两个相邻珠子具有不同颜色的次数。 这里，珠子1具有与珠子2不同的颜色，珠子3具有与珠子4不同的颜色。因此，有2次出现相邻的珠子具有不同的颜色。**


**现在，我们必须将这个想法扩展到n个任意颜色的珠子。 为此，我们可以使用一个名为“previous”的变量。 当我们读到每个珠子时，我们检查它的颜色是否与之前不同; 如果是，我们增加一个计数器。 然后，我们将“previous”的值设置为当前珠子的颜色。 这样，我们就可以跟踪两个相邻珠子的不同颜色的次数。**

```
read n
read a
previous = a
for i from 2 through n:
    read a
    if previous != a:
        counter++
    previous = a

print counter
```
